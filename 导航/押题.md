# HTML

## HTML 5 有哪些新标签？



文章相关：header main footer nav section article figure mark 

多媒体相关：video audio svg canvas 

表单相关：type=email type=tel

https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element

## Canvas 和 SVG 的区别是什么？

答题思路为：先说一，再说二，再说相同点，最后说不同点。

1. Canvas 主要是用笔刷来绘制 2D 图形的。 
2.  SVG 主要是用标签来绘制不规则矢量图的。 
3. 相同点：都是主要用来画 2D 图形的。
4.  不同点：Canvas 画的是位图，SVG 画的是矢量图。
5.  不同点：SVG 节点过多时渲染慢，Canvas 性能更好一点，但写起来更复杂。
6.  不同点：SVG 支持分层和事件，Canvas 不支持，但是可以用库实现。 



基本上考看别人的总结和平时自己写博客总结，否则答不好。

## 如何理解 HTML 中的语义化标签

答法如下： 

1. 是什么：语义化标签是一种写 HTML 标签的方法论/方式。 
2. 怎么做：实现方法是遇到标题就用 h1 到 h6，遇到段落用 p，遇到文章用 article，主要内容用 main，边栏用 aside，导航用 nav……（就是找到中文对应的 英文） 
3. 解决了什么问题：明确了 HTML 的书写规范 
4. 优点是：一、适合搜索引擎检索；二、适合人类阅读，利于团队维护。 
5. 缺点是：没有。
6. 怎么解决缺点：无需解决。

 总结：「是什么、怎么做、解决了什么问题、优点是、缺点是、怎么解决缺点」



# CSS

## BFC 是什么

答题思路还是「是什么、怎么做、解决了什么问题、优点是、缺点是、怎么解决缺点」

**是什么：**

避免回答，直接把 BFC 翻译成中文「块级格式化上下文」即可，千万别解释。

**怎么做：**

背诵 BFC 触发条件，虽然 [MDN 的这篇文章](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context) 列举了所有触发条件，但本押题告诉你只用背这几个就行了

- 浮动元素（元素的 float 不是 none）

- 绝对定位元素（元素的 position 为 absolute 或 fixed）

- 行内块 inline block 元素

- overflow 值不为 visible 的块元素

- 弹性元素（display为 flex 或 inline-flex元素的直接子元素）

**解决了什么问题：**

1. 清除浮动（为什么不用 .clearfix 呢？）

1. 防止 margin 合并

1. 某些古老的布局方式会用到（已过时）

**优点：**无。

**缺点：**有副作用。

**怎么解决缺点：**使用最新的 `display: flow-root` 来触发 BFC 就没有副作用了，但是很多人不知道。

## 如何实现垂直居中？



## CSS 选择器优先级如何确定

## 如何清除浮动？

实践题，建议写博客，甩链接。

方法一，给父元素加上 .clearfix

```
.clearfix:after{
     content: '';
     display: block; /*或者 table*/
     clear: both;
 }
 .clearfix{
     zoom: 1; /* IE 兼容*/
 }
```

方法二，给父元素加上 overflow:hidden。

## 两种盒模型（box-sizing）的区别？

答题思路为：先说一，再说二，再说相同点，最后说不同点。

第一种盒模型是 content-box，即 width 指定的是 content 区域宽度，而不是实际宽度，公式为

> 实际宽度 = width + padding + border

第二种盒模型是 border-box，即 width 指定的是左右边框外侧的距离，公式为

> 实际宽度 = width

相同点是都是用来指定宽度的，不同点是 border-box 更好用。

一点有意思的小历史，请看视频。

# JavaScript

## JS 的数据类型有哪些？

字符串、数字、布尔、undefined、null、大整数、符号、对象 

string、number、boolean、undefined、null、bigint、symbol、object 

提了就零分的答案有：数组、函数、日期。这些是类 class，不是类型 type

## 原型链是什么？

大概念题，答题思路为大概念化成小概念（分割），抽象化成具体（举例）。

举例，解决问题：没有class的情况下实现继承。简单优雅，不支持私有属性

https://www.zhihu.com/question/56770432/answer/315342130

## 这段代码中的 this 是多少？

看调用，看call  apply  bind  看new  箭头函数没有this

## JS 的 new 做了什么？

1. 创建临时对象/新对象 
2. 绑定原型
3. 指定 this = 临时对象

4. 执行构造函数 
5. 返回临时对象

https://zhuanlan.zhihu.com/p/23987456

## JS 的立即执行函数是什么？

是什么，声明一个匿名函数，然后立即执行它。这种做法就是立即执行函数。

怎么做，

```js
(function(){alert('我是匿名函数')} ()) // 用括号把整个表达式包起来
(function(){alert('我是匿名函数')})() // 用括号把函数包起来 !function()
{alert('我是匿名函数')}() // 求反，我们不在意值是多少，只想通过语法检查。
+function(){alert('我是匿名函数')}() -function(){alert('我是匿名函数')}()
~function(){alert('我是匿名函数')}() void function(){alert('我是匿名函数')}() 
new function(){alert('我是匿名函数')}() 
var x = function(){return '我是匿名函数'}()
```



解决了什么问题，在 ES6 之前，只能通过它来「创建局部作用域」。

优点是，兼容性好。

缺点是，

怎么解决缺点：使用 ES6 的 block + let 语法，即



## JS 的闭包是什么？怎么用？

是什么   闭包是 JS 的一种语法特性。是什么 闭包是 JS 的一种语法特性。

怎么做

```js
把这段代码放到 非全局环境=立即执行函数 
let count 
function add(){count+=1}

//
const x = function(){
    var count = 0
    return function add(){
        count += 1
        console.log(count)
    }
}()

```

解决了什么问题

1. 避免污染全局环境。（因为用的是局部变量） 
2. 提供对局部变量的间接访问。（因为只能 count += 1 不能 count -= 1） 
3. 维持变量，使其不被垃圾回收。

优点：简单 好用

缺点：闭包使用不当可能造成内存泄露。

怎么解决缺点：少用



## JS 如何实现类？

使用原型

```js
function Dog(name){ //构造函数
    this.name = name 
    this.legsNumber = 4 
}
//添加原型方法
Dog.prototype.kind = '狗'  
Dog.prototype.say = function(){ 
    console.log(`汪汪汪~ 我是${this.name}，我有${this.legsNumber}条腿。`) 
} 
Dog.prototype.run = function(){
    console.log(`${this.legsNumber}条腿跑起来。`) 
}
//new 
const d1 = new Dog('啸天') // Dog 函数就是一个类 d1.say()
```

class

```js
class Dog { 
    kind = '狗' // 等价于在 constructor 里写 this.kind = '狗'
    constructor(name) { 
       this.name = name 
       this.legsNumber = 4// 思考：kind 放在哪，放在哪都无法实现上面的一样的效果 
    } 
    say(){ console.log(`汪汪汪~ 我是${this.name}，我有${this.legsNumber}条腿。`) } 
    run(){console.log(`${this.legsNumber}条腿跑起来。`) } 
} 
const d1 = new Dog('啸天') 
d1.say()
```



## JS 如何实现继承？

原型链

```js
function Animal(legsNumber){ 
   this.legsNumber = legsNumber 
}
Animal.prototype.kind = '动物' 
function Dog(name){ 
    this.name = name
    Animal.call(this, 4) // 关键代码1 
} 
Dog.prototype.__proto__ = Animal.prototype // 关键代码2，但这句代码被禁用了，怎么办 
Dog.prototype.kind= '狗' 
Dog.prototype.say = function(){ 
console.log(`汪汪汪~ 我是${this.name}，我有${this.legsNumber}条腿。`) 
} 
const d1 = new Dog('啸天')
console.dir(d1)
```





class

```js
class Animal{ 
    constructor(legsNumber){ 
    this.legsNumber = legsNumber 
}
    run(){}
 } 
class Dog extends Animal{ 
    constructor(name) { 
        super(4)
        this.name = name 
    } 
    say(){ console.log(`汪汪汪~ 我是${this.name}，我${this.legsNumber}条腿。`) 
    } 
}
```



## 手写节流 throttle、防抖 debounce

节流和防抖都是优化高频率代码的一种方式。

一定时间内，只执行一次，在这个时间内触发都不会再执行一次。

判断是否在计时,没有计时返回函数并重置计时器，在计时中就等待时间过去

使用场景：

- 高频点击按钮

```javascript
//节流 类似技能冷却

const throttle = (fn,time)=>{
    let timeId = false
    return (...args)=>{
        if(timeId) return
        fn.call(undefined, ...args)
        timeId = true
        setTimeout(()=>{
            timeId = false
        },time)
    }
}
const d = throttle(()=>{console.log('hi')}, 1000)

```

防抖

一定时间后执行函数，此时间内执行，则重新计时，

判断是否在计时，在计时则清除计时器重新计时，没有计时则调用函数，重置计时器。

使用场景

- 高频更改窗口页面大小

```javascript
//防抖 类似游戏回城
const debounce = (fn,time)=>{
    let timeId = null
    return (...args)=>{
        if(timeId){
            clearTimeout(timeId)
        }
        timeId  = setTimeout(()=>{
            fn.call(undefined, ...args)
            timeId = null
        },time)
    }
}
const  d = debounce(()=>{console.log('hi')}, 1000)
```





## 手写发布订阅

发布订阅是一种设计模式

1 任务队列，映射 ---> 哈希表，

2 防御式编程

3 短路法(设计模式)

4 alias(设计模式) 缩写 别名 最好用于读操作

```javascript
const eventHub = {
    map: {}// 1
    on: (name, fn)=>{//写
        eventHub.map[name] =  eventHub.map[name] || [] // 2
        eventHub.map[name].push(fn)
    },
    emit: (name, data)=>{
        const q = eventHub.map[name] //4
        if(!q) return
        q.map(f=>f.call(undefined,data))
        return undefined
    },
    off: (name, fn)=>{//读
        const q = eventHub.map[name] //4
        if(!q){return}
        const index = q.indexOf(fn)
        if(index<0){return} //3
        q.splice(index,1)
        
    },
    once:()=>{}
}

eventHub.on('click',console.log)
eventHub.on('click',console.error)
setTimeout(()=>{
    eventHub.emit('click', 'Hi')
},3000)
```

class

```javascript
class EventHub {
    map = {}
	on(name,fn){
        this.map[name] = this.map[name]||[]
        this.map[name].push(fn)
    }
	emit(name,data){
        const fnList = this.map[name] || []
        fnList.forEach(fn=>fn.call(undefined, data))
    }
    off(name,fn){
        const fnList = this.map[name] || []
        const index = fnList.indexOf(fn)
        if(index<0)return
        fnList.splice(index,1)
    }
}
const e = new EventHub()
```





## 手写 AJAX

AJAX: async JavaScript and XML(JSON) 用于数据请求

Axios  jquery VueResource window.fetch

```javascript
 var request = new XMLHttpRequest()
 request.open('GET', '/a/b/c?name=ff', true);
 request.onreadystatechange = function () {
   if(request.readyState === 4 && request.status === 200) {
     console.log(request.responseText);
   }};
 request.send();
```





## 手写简化版 Promis

```javascript
class Promise2{
    //私有属性
    #status = 'pending' 
    constructor(fn){
        this.q = []
        const resolve = (data)=>{
            this.#status = 'fulfilled'
            const f1f2 = this.q.shift()
            if(!f1f2 || !f1f2[0])return
            const x = f1f2[0].call(undefined,data)
            if(x instanceof Promise2){
                x.then((data)=>{
                    //成功调用下一个f1
                    resolve(data)
                },(reason)=>{
                    //失败调用下一个f2
                    reject(reason)
                })
            }else{
                //调用下一个f1
                resolve(x)
            }
        }
        const reject = (reason)=>{
            this.#status = 'rejected'
             const f1f2 = this.q.shift()
             if(!f1f2 || !f1f2[1])return
            const x = f1f2[1].call(undefined,reason)
            if(x instanceof Promise2){
                x.then((data)=>{
                    //成功调用下一个f1
                    resolve(data)
                },(reason)=>{
                    //失败调用下一个f2
                    reject(reason)
                })
            }else{
                //调用下一个f1
                resolve(x)
            }
        }
        fn.call(undefined, resolve,reject)
    }
    then(f1,f2){
        this.q.push([f1,f2])
    }
    
}


const  p = new Promise2(function(resolve,reject){
   setTimeout(function(){
       resolve('hi')
   },3000)
})
p.then((data)=>console.log(data),(reason)=>{console.error(reason)})
    .then(()=>console.log(3),()=>{console.log(4)})//报错
```



## 手写简化版 Promis.all

```javascript
Promise.all2 = (promiseList)=>{
     return new Promise((resolve,reject)=>{
        const result = []
        const length = promiseList.length
    	//const exit () => {}
        let count = 0
        promiseList.map((promise,index)=>{
            promise.then((data)=>{
                result[index] = data
                count += 1
                if(count===length-1){
                    resolve(result)
                }
            },(r)=>{
                reject(r)
            })
    	})
    })
}

const promiseList = [Promise.resolve(1),Promise.resolve(2),Promise.resolve(3)]
Promise.all2(promiseList).then(data=>console.log(data),r=>console.error(r))
```



## 手写深拷贝

```javascript
JSON.parse(JSON.stringify(a))
```

不支持正则，Date，undefined，函数等数据，不支持引用（环状结构）

递归：

- 递归
- 判断类型
- 检查环
- 不拷贝原型上的属性

```js
const deepClone = (a,cache)=>{
    if(!cache){//缓存不能全局，临时创建并传递传递
        cache = new Map()//解决引用| 检查环
    }
    if(a instanceof Object){//不考虑 iframe
        if(cache.get(a)){return cache.get(a)}
        let result
        if(a instanceof Function){
            if(a.prototype){//有prototype就是普通函数
                result = function(){return a.apply(this,arguments)}
            }else{
                result = (...args) => {return a.call(undefined,...args)}
            }
        }else if(a instanceof Array){
            result = []
        }else if(a instanceof Date){
            result = new Date(a - 0)//时间戳
        }else if(a instanceof RegExp){
            result = new RegExp(a.source,a.flags)
        }else{
            result= {}
        }
        cache.set(a,result)
        for(let key in a){
            if(a.hasOwnProperty(key)){//拷贝自身属性，不拷贝原型属性
                result[key] = deepClone(a[key],cache)
            }
        }
        return result
    }else{
        return a
    }
}

const a = {
    number:1,bool:false,str:'hi',empty1:undefined,empty2:null,
    array:[
        {name:'js',str:'javaScript'}
    ],
    data:new Date(200,0,1,20,30,0),
    regex: /\.(j|t)sx/i,
    obj:{name:'name',age:11},
    f1:(a,b)=>a+b,
    f2:function(a,b){return a + b}
}
a.self = a
const b = deepClone(a)
b.self === b
```



## 手写数组去重

set

```javascript
Array.from(new Set(array))
[...new Set(array)]
```

计数排序

先遍历数组，把数组转化为传到map的key。然后把key push数组result。

```javascript
var uniq =function(a){
    var map = {}
    for(let i=0;i<a.length; i++){
        let number = a[i]
        if(number === undefined){continue}
        if(number in map){
           continue //跳过继续循环
        }
        map[number] = true
    }
    //return Object.keys(map)  //or
    const result = []
    for(let key in map){
        result.push(key)
    }
    return result
}
```

缺点：只能把数字变成字符串，分不出数组里的字符串和数组，

Map()

```javascript
var uniq =function(a){
    var map = new Map() //key 任意类型
    for(let i=0;i<a.length; i++){
        let number = a[i]
        if(number === undefined){continue}
        if(number.has(number)){
           continue //跳过继续循环
        }
        map.set(number,true)
    }
    return [...map.keys]
  }
    
}
```



# TypeScript 

## TS 和 JS 的区别是什么？有什么优势？

1. 语法层面：TypeScript = JavaScript + Type（TS 是 JS 的超集） 
2. 执行环境层面：浏览器、Node.js 可以直接执行 JS，但不能执行 TS（Deno 可以 执行 TS） 
3. 编译层面：TS 有编译阶段，JS 没有编译阶段（只有转译阶段和 lint 阶段）
4. 编写层面：TS 更难写一点，但是**类型更安全**
5. 文档层面：TS 的代码写出来就是文档，IDE 可以完美**提示**。JS 的提示主要靠 TS 其他……自己搜一下博客

## any、unknown、never 的区别是什么？

**any V.S. unknown**

二者都是**顶级类型**（top type），任何类型的值都可以赋值给顶级类型变量：

```
let foo: any = 123; // 不报错
let bar: unknown = 123; // 不报错
```

但是 unknown 比 any 的类型检查更严格，any 什么检查都不做，unknown 要求先收窄类型：

```
const value: unknown = "Hello World";
const someString: string = value; 
// 报错：Type 'unknown' is not assignable to type 'string'.(2322)
const value: unknown = "Hello World";
const someString: string = value as string; 
// value as string类型收窄 不报错
```

如果改成 any，基本在哪都不报错。所以能用 unknown 就优先用 unknown，类型更安全一点。

**never**

never 是**底类型**，表示不应该出现的类型，这里有一个[尤雨溪给出的例子](https://www.zhihu.com/question/354601204/answer/888551021)：

```
interface A {
  type: 'a'
}

interface B {
  type: 'b'
}

type All = A | B

function handleValue(val: All) {
  switch (val.type) {
    case 'a':
      // 这里 val 被收窄为 A
      break
    case 'b':
      // val 在这里是 B
      break
    default:
      // val 在这里是 never 不应该出现的类型
      const exhaustiveCheck: never = val
      break
  }
}
```

现在你应该理解什么是「不应该出现的类型」了吧。

## type 和 interface 的区别是什么？

官方给出的[文档说明](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)：

1. 组合方式：interface 使用 extends 来实现继承，type 使用 & 来实现联合类型。写法不一样
2. 扩展方式：interface 可以重复声明用来扩展，type 一个类型只能声明一次
3. 范围不同：type 适用于基本类型，interface 一般不行。
4. 命名方式：interface 会创建新的类型名，type 只是创建类型别名，并没有新创建类型。

其他……建议搜一下博客。



## TS 工具类型 Partial、Required、Readonly、Exclude、Extract、Omit、 ReturnType 的作用和实现

1. 将英文翻译为中文。 

   ​	a. Partial       部分类型 

   ​	b. Required 必填类型 

   ​	c. Readonly 只读类型 

   ​	d. Exclude   排除类型--非对像

      e. Extract    提取类型

      f. Pick/Omit 排除 key 类型--对象

   ​	g. ReturnType 返回值类型 

2. 举例说明每个工具类型的用法。

# DOM 押题

## 请简述 DOM 事件模型

先经历从上到下的捕获阶段，再经历从下到上的冒泡阶段。     

addEventListener(’click’,fn,true/false) 第三个参数可以选择阶段。默认冒泡，true为捕获  

 event.stopPropagation() 来阻止捕获或冒泡。

## 手写事件委托

```js
ul.addEventListener('click', function(e){
    if(e.target.tagName.toLowerCase() === 'li'){
        //e.target 用户触发对象，
       // e.currentTarget ul
        fn()// 执行某个函数 
    } 
})
```

bug 在于，如果用户点击的是 li 里面的 span，就没法触发 fn，这显然不对。 

好处 

1. 节省监听器 

2. 实现动态监听

 坏处 调试比较复杂，不容易确定监听者。 

解决坏处 解决不了

**思路是点击 span 后，递归遍历 span 的祖先元素看其中有没有 ul 里面的 li**

```js
function delegate(element, eventType, selector, fn) {
    element.addEventLisener(eventType, e => { 
        let el = e.target 
        while (!el.matches(selector)) {//matches 指定选择器元素
            if (element === el) { 
                el = null break 
            } 
            el = el.parentNode 
        } 
        el && fn.call(el, e, el) 
    }) 
    return element 
} 
delete(ul, 'click', 'li', f1)
```

## 手写可拖曳div

```js
var dragging = false //是否移动
var position = null

xxx.addEventListener('mousedown',function(e){
    //mousedown 事件在指针设备按钮按下时触发。
  dragging = true //true 移动
  position = [e.clientX, e.clientY]//记录mousedown触发时的坐标
})


document.addEventListener('mousemove', function(e){
    //当指针设备( 通常指鼠标 )在元素上移动时, mousemove 事件被触发。
  if(dragging === false){return} // flase 不移动
  console.log('hi')
  const x = e.clientX  
  const y = e.clientY 
  const deltaX = x - position[0] //获得每次移动坐标长度
  const deltaY = y - position[1]
  const left = parseInt(xxx.style.left || 0)
  const top = parseInt(xxx.style.top || 0)
  xxx.style.left = left + deltaX + 'px' //变更style坐标
  xxx.style.top = top + deltaY + 'px'
  position = [x, y] //记录此次xy坐标
})
document.addEventListener('mouseup', function(e){
    //mouseup 事件在指针设备（如鼠标或触摸板）按钮放开时触发
  dragging = false
})
```



要点：

1. 注意监听范围，不能只监听 div 
2. 不要使用 drag 事件，很难用。 
3. 使用 transform 会比 top / left 性能更好，因为可以避免 reflow 和 repaint



### 事件

系统内发生的动作或者发生的事情

例如点击按钮，显示消息框回应这个动作

- 用户在某个元素上点击鼠标或悬停光标。
- 用户在键盘中按下某个按键。
- 用户调整浏览器的大小或者关闭浏览器窗口。
- 一个网页停止加载。
- 提交表单。
- 播放、暂停、关闭视频。
- 发生错误。

每个事件都有一个事件处理器或者事件监听器——触发时运行的代码块，

常见网页事件

- 事件处理器的属性

  - element.onclick
  - element.onfocus 获取焦点触发
  - element.onblur  失去焦点触发
  - element.ondblclick 按钮双击时触发
  - element.onmouseover|onmouseout 鼠标移入移出按钮上方时触发

- addEventListener(type,listener,options)  removeEventListener()

  - type 监听事件类型的字符串
  - 监听事件
  - options ：
    - capture  事件捕获阶段传播到时触发
    - once  最多调用一次
    - passive  true  则不调用listener
    - signal: [`AbortSignal`](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal) abort方法调用时，监听器会被移除

  

- 其他事件

  - 事件对象 `e`
  - 阻止默认行为   `preventDefault`
  - 冒泡捕获 `stopPropagation ` 组织冒泡
  - 事件委托

#### [事件属性](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseup_event#%E5%8F%82%E8%A7%81)



# HTTP

## GET 和 POST 的区别有哪些？

**根据技术规格文档，GET 和 POST 最大的区别是语义；但面试官一般问的是 实践过程中二者的区别，因此你需要了解服务器和浏览器对 GET 和 POST 的 常见实现方法。**

区别一：幂等性 (重复多遍但不改变结果)

1. 由于 GET 是读，POST 是写，所以 GET 是幂等的，POST 不是幂等的。
2. 由于 GET 是读，POST 是写，所以用浏览器打开网页会发送 GET 请求，想要 POST 打开网页要用 form 标签。
3. 由于 GET 是读，POST 是写，所以 GET 打开的页面刷新是无害的，POST 打开的 页面刷新需要确认。
4. 由于 GET 是读，POST 是写，所以 GET 结果会被缓存，POST 结果不会被缓存。
5. 由于 GET 是读，POST 是写，所以 GET 打开的页面可被书签收藏，POST 打开的 不行。



 区别二：请求参数 

1. 通常，GET 请求参数放在 url 里，POST 请求数据放在 body（消息体）里。（这 里注意老师的讲解） 
2. GET 比 POST 更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信 息。（xjb扯） 
3. GET 请求参数放在 url 里是有长度限制的，而 POST 放在 body 里没有长度限制。 （xjb扯） 

区别三：TCP packet 

1. GET 产生一个 TCP 数据包；POST 产生两个或以上 TCP 数据包。



## HTTP 缓存有哪些方案？

- 强缓存   
- 内容协商弱缓存

|          | 缓存 强缓存                                                  | 内容协商  弱缓存                                             |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| HTTP 1.1 | Cache-Control:max-age=3600 <br />Etag:ABC                    | If-None-Match:ABC  <br />响应状态码：304 200                 |
| 优缺点   | 设置过期时间<br />Etage用于缓存过期后询问服务器ABC文件是否能用，能用直接用 | 协商文件是否需要删除&更新，<br />304不删除，200删除更新      |
| HTTP 1.0 | Expires:Web,21 Oct 2015 02:30:00 GMT<br />Last-Modified:Web21 Oct 2015 02:30:00 GMT | If-Modified-SinceWeb,21 Oct 2015 02:30:00 GM<br />响应状态码：304 200 |
| 优缺点   | Expries: 服务器时间和客户端时间错误<br />Last-Modified 最后一次更新时间 |                                                              |

ajax 发布no-cache 删除强缓存

## HTTP 和 HTTPS 的区别有哪些？

HTTPS = HTTP + SSL/TLS（安全层）

区别列表

1. HTTP 是明文传输的，不安全；HTTPS 是加密传输的，非常安全。 
2. HTTP 使用 80 端口，HTTPS 使用 443 端口。
3. HTTP 较快，HTTPS 较慢。 
4. HTTPS 的证书一般需要购买（但也有免费的），HTTP 不需要证书。

 HTTPS 的细节可以看网上的博客，比较复杂，难以记忆，建议写博客总结一下。 图解SSL/TLS协议 - 阮一峰的网络日志 (ruanyifeng.com) HTTPS原理以及握手阶

https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html

https://juejin.cn/post/6844903892765900814

- 非对称加密
- 对称加密
- 伪造百度，但证书伪造不了

## HTTP/1.1 和 HTTP/2 的区别有哪些？

区别列表

1. HTTP/2 使用了**二进制**传输，而且将 head 和 body 分成帧来传输；HTTP/1.1 是**字 符串**传输。 
2. HTTP/2 支持**多路复用**，HTTP/1.1 不支持。多路复用简单来说就是一个 TCP 连接 从单车道（不是单行道）变成了几百个双向通行的车道。
3. HTTP/2 可以**压缩 head**，但是 HTTP/1.1 不行。 
4. HTTP/2 支持**服务器推送**，但 HTTP/1.1 不支持。（实际上没多少人用）

## TCP 三次握手和四次挥手是什么？

TCP 传输内容协议

建立 TCP 连接时 server 与 client 会经历三次握手 

1. 浏览器向服务器发送 TCP 数据：SYN(seq=x) 
2. 服务器向浏览器发送 TCP 数据：ACK(seq=x+1) SYN(y) 
3. 浏览器向服务器发送 TCP 数据：ACK(seq=y+1)

 关闭 TCP 连接时 server 与 client 会经历四次挥手

1. 浏览器向服务器发送 TCP 数据：FIN(seq=x)
2. 服务器向浏览器发送 TCP 数据：ACK(seq=x+1)
3. 服务器向浏览器发送 TCP 数据：FIN(seq=y) 
4. 浏览器向服务器发送 TCP 数据：ACK(seq=y+1) 

为什么 2、3 步骤不合并起来呢？看起来是脱裤子放屁。 答案：2、3 中间服务器很可能还有数据要发送，不能提前发送 FIN。

## 说说同源策略和跨域

**同源策略是什么？**

如果两个 URL 的协议、端口和域名都完全一致的话，则这两个 URL 是同源的。

```
http://www.baidu.com/s 
http://www.baidu.com:80/ssdasdsadad
```

**同源策略怎么做？**

只要在**浏览器**里打开页面，就默认遵守同源策略。 

**优点**

保证用户的隐私安全和数据安全。

**缺点**

很多时候，前端需要访问另一个域名的后端接口，会被浏览器阻止其获取响应。

比如甲站点通过 AJAX 访问乙站点的 /money 查询余额接口，请求会发出，但是响应会被浏览器屏蔽。

**怎么解决缺点**

使用跨域手段。

1. JSONP（前端体系课有完整且详细的介绍）

    1. 甲站点利用 script 标签可以跨域的特性，向乙站点发送 get 请求。
    2. 乙站点**后端改造** JS 文件的内容，将数据传进回调函数。
    3. 甲站点通过回调函数拿到乙站点的数据。

2. CORS（前端体系课有完整且详细的介绍）

    1. 对于简单请求，乙站点在响应头里添加 `Access-Control-Allow-Origin: http://甲站点` 即可。
    2. 对于复杂请求，如 PATCH，乙站点需要：
    3. 响应 OPTIONS 请求，在响应中添加如下的响应头

    ```
    Access-Control-Allow-Origin: https://甲站点
    Access-Control-Allow-Methods: POST, GET, OPTIONS, PATCH
    Access-Control-Allow-Headers: Content-Type
    ```

    1. 响应 POST 请求，在响应中添加 `Access-Control-Allow-Origin` 头。
    2. 如果需要附带身份信息，JS 中需要在 AJAX 里设置 `xhr.withCredentials = true` 。

3. Nginx 代理 / Node.js 代理

    1. 前端 ⇒ 后端 ⇒ 另一个域名的后端

    详情参考 [MDN CORS 文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)。

## Session、Cookie、LocalStorage、SessionStorage 的区别

• **Cookie  V.S. LocalStorage (html5) ** 

1. 主要区别是 Cookie 会被发送到服务器，而 LocalStorage 不会
2. Cookie 一般最大 4k，LocalStorage 可以用 5Mb 甚至 10Mb（各浏览器不 同） 

• **LocalStorage V.S. SessionStorage**

1. LocalStorage 一般不会自动过期（除非用户手动清除）

2. SessionStorage 在回话结束时过期（如关闭浏览器之后，具体由浏览器自行 决定）

   

 • **Cookie V.S. Session** 

1. Cookie 存在浏览器的文件里，Session 存在服务器的文件里 

2. Session 是基于 Cookie 实现的，具体做法就是把 SessionID 存在 Cookie 里 

   

**其他区别请在网上找高票答案看看，自己写文章总结一下。**

# Vue2

## Vue 2 的生命周期钩子有哪些？数据请求放在哪个钩子？

Vue 2 文档写得很清楚，红色空心框中的文字皆为生命周期钩子：

1. create x 2 (before + ed) - SSR  有可能在后端再执行一次

1. mount x 2

1. update x 2

1. destroy x 2

还有三个写在[钩子列表](https://cn.vuejs.org/v2/api/#选项-生命周期钩子)里：

1. [activated](https://cn.vuejs.org/v2/api/#activated)
    1. 被 keep-alive 缓存的组件激活时调用。
    1. **该钩子在服务器端渲染期间不被调用。**
1. [deactivated](https://cn.vuejs.org/v2/api/#deactivated)
    1. 被 keep-alive 缓存的组件失活时调用。
    1. **该钩子在服务器端渲染期间不被调用。**
1. [errorCaptured](https://cn.vuejs.org/v2/api/#errorCaptured)
    1. 在捕获一个来自后代组件的错误时被调用。

请求放在 mounted 里面，因为放在其他地方都不合适（xjb扯）。

## Vue 2 组件间通信方式有哪些？

1. 父子组件：使用「props 和事件」进行通信

1. 爷孙组件：

    1. 使用两次父子组件间通信来实现

    1. 使用「provide + inject」来通信

1. 任意组件：使用 eventBus = new Vue() 来通信

    1. 主要API 是 eventBus.$on 和 eventBus.$emit

    1. 缺点是事件多了就很乱，难以维护

1. 任意组件：使用 Vuex 通信（Vue 3 可用 Pinia 代替 Vuex）

## Vuex 用过吗？怎么理解？

1. 背下文档第一句：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库

1. 说出核心概念的名字和作用：store/State/Getter/Mutation/Action/Module

    1. store 是个大容器，包含以下所有内容

    1. State 用来读取状态，带有一个 mapState 辅助函数

    1. Getter 用来读取派生状态，附有一个 mapGetters 辅助函数

    1. Mutation 用于**同步**提交状态变更，附有一个 mapMutations 辅助函数

    1. Action 用于**异步**变更状态，但它提交的是 mutation，而不是直接变更状态。

    1. Module 用来给 store 划分模块，方便维护代码

常见追问：Mutation 和 Action 为什么要分开？

答案：为了让代码更易于维护。（可是 Pinia 就把 Mutation 和 Action 合并了呀）

完。

## VueRouter 用过吗？怎么理解？

1. 背下文档第一句：Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。

1. 说出核心概念的名字和作用：`router-link` `router-view` 嵌套路由、Hash 模式和 History 模式、导航守卫、懒加载import()

1. 常见追问：

    1. Hash 模式和 History 模式的区别？

        1. 一个用的 Hash，一个用的 History API

        1. 一个不需要后端 nginx 配合，一个需要

    1. 导航守卫如何实现登录控制？

        ```typescript
        router.beforeEach((to, from, next) => {
          if (to.path === '/login') return next()
          if (to是受控页面 && 没有登录) return next('/login')
          next()
        })
        ```

推荐阅读：https://blog.csdn.net/sinat_36521655/article/details/106125910

## Vue 2 是如何实现双向绑定的？

1. 说明一般使用 `v-model`/ `.sync`实现，`v-model` 是 `v-bind:value`

    和 `v-on:input`的语法糖

    1. `v-bind:value` 实现了 data ⇒ UI 的单向绑定

    1. `v-on:input` 实现了 UI ⇒ data 的单向绑定

    1. 加起来就是双向绑定了

1. 这两个单向绑定是如何实现的呢？

    1. 前者通过 Object.defineProperty API 给 data 创建 getter 和 setter，用于监听 data 的改变，data 一变就会安排改变 UI

    1. 后者通过 template compiler 给 DOM 添加事件监听，DOM input 的值变了就会去修改 data。

网上的博客讲得很绕，你可以尝试理解看看。https://www.cnblogs.com/canfoo/p/6891868.html

# Vue3

## Vue 3 为什么使用 Proxy？

1. 弥补 Object.defineProperty 的两个不足

    1. 动态创建的 data 属性需要用 Vue.set 来赋值，Vue 3 用了 Proxy 就不需要了

    1. 基于性能考虑，[Vue 2 篡改了数组的 7 个 API](https://cn.vuejs.org/v2/guide/list.html#变更方法)，Vue 3 用了 Proxy 就不需要了

1. defineProperty 需要提前递归地遍历 data 做到响应式，而 Proxy 可以在真正用到深层数据的时候再做响应式（惰性）

## Vue 3 为什么使用 Composition API？

[Vue Function-based API RFC - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/68477600)

1. Composition API 比 mixins、高阶组件、extends、Renderless Components 等更好，原因有三：

    1. 模版中的数据来源不清晰。

    1. 命名空间冲突。

    1. 性能。——> Renderless Components 

1. 更适合 TypeScript

## Vue 2 做了哪些改动

[官方文档](https://v3-migration.vuejs.org/breaking-changes/)写了（[中文在这](https://v3.cn.vuejs.org/guide/migration/introduction.html#非兼容的变更)），这里列出几个容易被考的：

1. createApp() 代替了 new Vue()

1. v-model 代替了以前的 v-model 和 .sync

1. 根元素可以有不止一个元素了

1. 新增 Teleport 传送门

1. destroyed 被改名为 unmounted 了（before 当然也改了）

1. ref 属性支持函数了

其他建议自己看看写写。

# React

## 虚拟 DOM 的原理是什么？

1. 是什么

    虚拟 DOM 就是虚拟节点（这句汉化很重要）。React 用 JS 对象来**模拟** DOM 节点，然后将其渲染成真实的 DOM 节点。

1. 怎么做

    **第一步是模拟**

    用 JSX 语法写出来的 div 其实就是一个虚拟节点：

    ```
    <div id="x">
      <span class="red">hi</span>
    </div>
    ```

    这代码会得到这样一个对象：

    ```
    {
      tag: 'div',
      props: {
        id: 'x'
      },
      children: [
        {
          tag: 'span',
          props: {
            className: 'red'
          },
          children: [
            'hi'
          ]
        }
      ]
    }
    ```

    能做到这一点是因为 JSX 语法会被转译为 createElement 函数调用（也叫 h 函数），如下：

    ```
    React.createElement("div", { id: "x"}, 
      React.createElement("span", { class: "red" }, "hi")
    )
    ```

    **第二步是将虚拟节点渲染为真实节点**

    ```
    function render(vdom) {
      // 如果是字符串或者数字，创建一个文本节点
      if (typeof vdom === 'string' || typeof vdom === 'number') {
        return document.createTextNode(vdom)
      }
      const { tag, props, children } = vdom
      // 创建真实DOM
      const element = document.createElement(tag)
      // 设置属性
      setProps(element, props)
      // 遍历子节点，并获取创建真实DOM，插入到当前节点
      children
        .map(render)
        .forEach(element.appendChild.bind(element))
    
      // 虚拟 DOM 中缓存真实 DOM 节点
      vdom.dom = element
      
      // 返回 DOM 节点
      return element
    }
    
    function setProps // 略
    function setProp // 略
    
    // 作者：Shenfq
    // 链接：https://juejin.cn/post/6844903870229905422
    ```

    注意，如果节点发生变化，并不会直接把新虚拟节点渲染到真实节点，而是先经过 diff 算法得到一个 patch 再更新到真实节点上。

1. 解决了什么问题

    1. DOM 操作性能问题。通过虚拟 DOM 和 diff 算法减少不必要的 DOM 操作，保证性能不太差

    1. DOM 操作不方便问题。以前各种 DOM API 要记，现在只有 setState

1. 优点

    1. 为 React 带来了跨平台能力，因为虚拟节点除了渲染为真实节点，还可以渲染为其他东西。

    1. 让 DOM 操作的整体性能更好，能（通过 diff）减少不必要的 DOM 操作。

1. 缺点

    1. 性能要求极高的地方，还是得用真实 DOM 操作（目前没遇到这种需求）

    1. React 为虚拟 DOM 创造了

        合成事件

        ，跟原生 DOM 事件不太一样，工作中要额外注意

        1. 所有 React 事件都绑定到根元素，自动实现事件委托

        1. 如果混用合成事件和原生 DOM 事件，有可能会出 bug

1. 如何解决缺点

    不用 React，用 Vue 3（笑）

## React 或 Vue 的 DOM diff 算法是怎样的？

1. 是什么

    DOM diff 就是对比两棵虚拟 DOM 树的算法（废话很重要）。当组件变化时，会 render 出一个新的虚拟 DOM，diff 算法对比新旧虚拟 DOM 之后，得到一个 patch，然后 React 用 patch 来更新真实 DOM。

1. 怎么做

    1. 首先对比两棵树的根节点

        1. 如果根节点的类型改变了，比如 div 变成了 p，那么直接认为整棵树都变了，不再对比子节点。此时直接删除对应的真实 DOM 树，创建新的真实 DOM 树。

        1. 如果根节点的类型没变，就看看属性变了没有

            1. 如果没变，就保留对应的真实节点

            1. 如果变了，就只更新该节点的属性，不重新创建节点。
                1. 更新 style 时，如果多个 css 属性只有一个改变了，那么 React 只更新改变的。

    1. 然后同时遍历两棵树的子节点，每个节点的对比过程同上。

        1. 情况一

            ```
            <ul>
              <li>A</li>
              <li>B</li>
            </ul>
            
            <ul>
              <li>A</li>
              <li>B</li>
              <li>C</li>
            </ul>
            ```

            React 依次对比 A-A、B-B、空-C，发现 C 是新增的，最终会创建真实 C 节点插入页面。

        1. 情况二

            ```
            <ul>
              <li>B</li>
              <li>C</li>
            </ul>
            
            <ul>
              <li>A</li>
              <li>B</li>
              <li>C</li>
            </ul>
            ```

            React 对比 B-A，会删除 B 文本新建 A 文本；对比 C-B，会删除 C 文本，新建 B 文本；（注意，并不是边对比边删除新建，而是把操作汇总到 patch 里再进行 DOM 操作。）对比空-C，会新建 C 文本。

            你会发现其实只需要创建 A 文本，保留 B 和 C 即可，为什么 React 做不到呢？

            因为 React 需要你加 key 才能做到：

            ```
            <ul>
              <li key="b">B</li>
              <li key="c">C</li>
            </ul>
            
            <ul>
              <li key="a">A</li>
              <li key="b">B</li>
              <li key="c">C</li>
            </ul>
            ```

            React 先对比 key 发现 key 只新增了一个，于是保留 b 和 c，新建 a。

        以上是官方文档的内容，但是面试官想听的可能是源码分析之「双端交叉对比」

        https://canyuegongzi.github.io/web/vue/3.html#updatechildren

        https://juejin.cn/post/6971622260490797069

## React 有哪些生命周期钩子函数？

React 的文档稍微有点乱，需要配合两个地方一起看才能记忆清楚：

https://reactjs.org/docs/react-component.html#the-component-lifecycle

https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

总得来说：

1. 挂载时调用 constructor，更新时不调用

1. 更新时调用 shouldComponentUpdate 和 getSnapshotBeforeUpdate，挂载时不调用

1. should... 在 render 前调用，getSnapshot... 在 render 后调用

1. 请求放在 componentDidMount 里，最好写博客，容易忘。

## React 如何实现组件间通信

1. 父子组件通信：props + 函数

1. 爷孙组件通信：两层父子通信或者使用 Context.Provider 和 Context.Consumer

1. 任意组件通信：其实就变成了状态管理了

    1. Redux 

    1. Mobx

    1. Recoil

## 你如何理解 Redux？

1. 文档第一句话背下来：Redux 是一个状态管理库/状态容器。 

1. 把 Redux 的核心概念说一下：

    1. State

    1. Action = type + payload 荷载

    1. Reducer 

    1. Dispatch 派发

    1. Middleware

1. 把 ReactRedux 的核心概念说一下：

    1. connect()(Component)

    1. mapStateToProps

    1. mapDispatchToProps

1. 说两个常见的中间件 redux-thunk redux-promise

https://www.bilibili.com/video/BV1dm4y1R7RK?from=search&seid=8579266903295629745&spm_id_from=333.337.0.0

## 什么是高阶组件 HOC？

参数是组件，返回值也是组件的函数。什么都能做，所以抽象问题就具体回答。

举例说明即可：

1. React.forwardRef

1. ReactRedux 的 connect

1. ReactRouter 的 withRouter

参考阅读：[「react进阶」一文吃透React高阶组件(HOC) - 掘金 (juejin.cn)](https://juejin.cn/post/6940422320427106335#heading-0)

## React Hooks 如何模拟组件生命周期？

1. 模拟 componentDidMount

1. 模拟 componentDidUpdate

1. 模拟 componentWillUnmount

代码示例如下：

```
import { useEffect,useState,useRef } from "react";
import "./styles.css";

export default function App() {
  const [visible, setNextVisible] = useState(true)
  const onClick = ()=>{
    setNextVisible(!visible)
  }
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      {visible ? <Frank/> : null}
      <div>
        <button onClick={onClick}>toggle</button>
        </div>
     
    </div>
  );
}

function Frank(props){
  const [n, setNextN] = useState(0)
  const first = useRef(true)
  useEffect(()=>{
    if(first.current === true ){
      return
    }
    console.log('did update')
  })
  useEffect(()=>{
    console.log('did mount')
    first.current = false
    return ()=>{
      console.log('did unmount')
    }
  }, [])
  
  const onClick = ()=>{
    setNextN(n+1)
  }
  return (
    <div>Frank
      <button onClick={onClick}>+1</button>
    </div>
  )
}
```

完。

# Node.js

## Node.js 的 EventLoop 是什么？

**背景知识**

[Event Loop、计时器、nextTick - 掘金JavaScript 是单线程的，有了 event loop 的加持，Node.js 才可以非阻塞地执行 I/O 操作，把这些操作尽量转移给操作系统来执行。 我们知道大部分现代操作系统都是多线程的，这些操作系统可以在后台执行多个操作。当某个操作结束了，操作系统就会通知 Node...![img](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/favicon-16x16.png)https://juejin.cn/post/6844903582538399752](https://juejin.cn/post/6844903582538399752)

Node.js 将各种函数（也叫任务或回调）分成至少 6 类，按先后顺序调用，因此将时间分为六个阶段：

1. timers 阶段（setTimeout）

1. I/O callbacks 该阶段不用管

1. idle, prepare 该阶段不用管

1. poll 轮询阶段，停留时间最长，可以随时离开。

    1. 主要用来处理 I/O 事件，该阶段中 Node 会不停询问操作系统有没有文件数据、网络数据等

    1. 如果 Node 发现有 timer 快到时间了或者有 setImmediate 任务，就会主动离开 poll 阶段

1. check 阶段，主要处理 setImmediate 任务

1. close callback 该阶段不用管

Node.js 会不停的从 1 ~ 6 循环处理各种事件，这个过程叫做事件循环（Event Loop）。

**nextTick**

process.nextTick(fn) 的 fn 会在什么时候执行呢？

在 Node.js 11 之前，会在每个阶段的末尾集中执行（俗称队尾执行）。

在 Node.js 11 之后，会在每个阶段的任务间隙执行（俗称插队执行）。

浏览器跟 Node.js 11 之后的情况类似。可以用 window.queueMicrotask 模拟 nextTick。

Promise

Promise.resolve(1).then(fn) 的 fn 会在什么时候执行？

这要看 Promise 源码是如何实现的，一般都是用 process.nextTick(fn) 实现的，所以直接参考 nextTick。

async / await 

这是 Promise 的语法糖，所以直接转为 Promise 写法即可。





面试题1：

```
setTimeout(() => {
  console.log('setTimeout')
})

setImmediate(() => {
  console.log('setImmediate')
})
// 在 Node.js 运行会输出什么？
// A setT setIm
// B setIm setT
// C 出错
// D A 或 B
// 在浏览器执行会怎样？
```



面试题2：

```
async function async1(){
    console.log('1')                   // 2
    async2().then(()=>{
      console.log('2')
    })
    
}
async function async2(){
    console.log('3')                   // 3
}
console.log('4')                        // 1
setTimeout(function(){
    console.log('5') 
},0)  
async1();
new Promise(function(resolve){
    console.log('6')                    // 4
    resolve();
}).then(function(){
    console.log('7')
})
console.log('8')                           // 5  
//4 1 3 6 8 2 7 5 
```